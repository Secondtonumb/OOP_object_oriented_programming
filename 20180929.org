** 对象数组
arrdef a[10];
*** 初始化
+ 利用初始值表
+ 没有显示调用赋值，则调用默认构造函数。
+ 初始值表短于数组长度 < 则剩余的调用默认构造函数。
+ 利用变换构造函数是，在初始值表中给出可以只给出参数。
* 继承
继承是C++语言的一个重要特点，他不仅简化了子类的定义，而且日用继承还可以达到软件复用的目的，同时可以提高软件的可靠性和缩短开发周期
** 7.1基类和派生类
通过使用已有的类并在此基础上追加新的功能可以派生出新的蕾。
被继承的类被称为基类，通过继承而产生的新类被称为派生类或到处类。
+ 在派生类中可以直接使用基类中所有的publiv和protected成员，但不能直接使用其private成员，这就是为什么不能在派生类的disp()函数中直接显示ya和yb的原因。
*** 对基类的访问控制
+ public
+ protected
+ privated
public >  protected > privated
+ 在派生类的构造函数中可以使用基类的构造函数
+ 在派生类的构造函数和成员函数中，可以调用基类中的非private成员函数
+ 在派生类中不能使用基类中的private成员
+ 如果在基类和派生类中有同名函数，则在派生类中来使用基类中的同名函数时，要利用作用域了限定运算符来加以区分
+ 在派生类中可以使用基类和派生类中的成员函数。
** 7.2 虚函数和多态
多态指一个名字代表多种具体的对象。
*** 7.2.1 静态结合和动态结合
*** 7.2.2 虚函数
虚函数是向系统表明采用动态结合方式和函数
virtual 
+ 在一个类中可以定义多个虚函数
  + 如果所调用的函数只在基类中存在，派生类中没有，直接调用基类中的函数。
  + 如果只在派生类中存在，积累中没有，将编译错误。
  + 如果利用p所调用的函数在基类和派生类中都存在，但不是虚函数，这时将调用基类中的函数。
  + 都存在且都是虚函数，将调用派生类中的函数。
+ 判断派生类中的某个函数funcX是否为虚函数很重要
  + funcX 与基类中的虚函数A有相同的函数名
  + funcX 与基类中的虚函数a有相同的参数个数与类型
  + 有相同的返回值类型
+ 构造函数，析构函数和虚函数不能定义为静态函数。同时，构造函数可以被定义为虚函数，而析构函数可以被定义为虚函数。

定义一个派生类的指针，指向基类的地址，是不可以的。因为存在不包含的成员。
即
  将派生类对象的地址赋给指向积累的指针或几类对象的引用并调用虚函数都可以实现多台，但将派生类对象赋给基类对象并以此来调用虚函数是不能实现多态的。

